Tree
---
### 一 概念
   #### 1.二叉树
    1.树：一个有N个节点的有序集合
    2.树的层次,根节点为一层，其子节点为第二层，依次类推。
    3.节点的度：节点拥有子树的个数，二叉树的度不大于2。
    4.树的度:度数最大的节点的度数。
    5.叶子：度数为0的节点。终端节点。
    6.高度：树的最大层数。
    7.二叉树：由一个结点和两颗互不相交、分别称为这个根的左子树和右子树的二叉树构成（递推定义）
    8.深度为k的二叉树，在全满情况下，最多有2^k-1个节点。
    9.二叉树第k层上至多有2^(k-1)个节点。
    10.单纯的二叉树在插入数据时，容易造成斜树。
    11.斜树：所有的结点都只有左子树（左斜树），或者只有右子树（右斜树）。这就是斜树
    12.满二叉树：所有分支节点都有左子树和右子树，且所有叶子节点都这同一层。
    13.完全二叉树:对一棵具有n个结点的二叉树按层序排号，如果编号为i的结点与同样深度的满二叉树编号为i结点在二叉树中位置完全相同，就是完全二叉树。
       满二叉树必须是完全二叉树，反过来不一定成立。
    14.平衡二叉树:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
    15.为了保证插入元素后，树是一颗平衡二叉树，需要平衡算法，红黑树、AVL、替罪羊树、Treap、伸展树
    16.二叉查找树的特点是每个非叶节点都只有两个孩子节点。然而这种做法会导致当数据量非常大时，二叉查找树的深度过深，搜索算法自根节点向下搜索时，需要访问的节点也就变的相当多。如果这些节点存储在外存储器中，每访问一个节点，相当于就是进行了一次I/O操作，随着树高度的增加，频繁的I/O操作一定会降低查询的效率。
---
   #### 2.多叉树
背景:对于外存储器的信息读取最大的时间消耗在于寻找磁盘页面。那么一个基本的想法就是能不能减少这种读取的次数，在一个磁盘页面上，多存储一些索引信息。B树的基本逻辑就是这个思路，它要改二叉为多叉，每个节点存储更多的指针信息，以降低I/O操作数。(寻找磁道是个机械化过程，耗费比较多的时间)
1.B树:
* 最小度为t的B树，每个节点最多包含2t-1个关键字(子节点)(最小度为2的B树，这棵树最多有3个关键字，最少1个关键字)
* 一个节点uu中的关键字按非降序排列,按顺序将子树范围分割。每个节点的关键字的值大于或小于其子树所有节点的关键字的值。
* 所有节点的高度h都是相同的，即树是平衡的。
* B树的高度满足如下公式h<=log_t((n+1)/2) ,搜索B树，访问节点的次数与高度成正比。
2.B树的插入，删除






#### url:
    数据结构中各种树 http://blog.jobbole.com/111680/
    很全面的算法和数据结构知识 http://blog.jobbole.com/110835/?utm_source=blog.jobbole.com&utm_medium=relatedPosts
    B树 https://blog.csdn.net/guoziqing506/article/details/64122287
