## reids

___

1.Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。
Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。客户端与Redis建立连接后会自动选择0号数据库，
不过可以随时使用SELECT命令更换数据库，如要选择1号数据库:SELECT 1

2.命令组有Cluster、Connection、Geo、Hashes、HyperLogLog、Keys、Lists、
Pub/Sub、Scripting、Server、Sets、Sorted Sets、Strings、Transactions
一共14个redis命令组两百多个redis命令

3.主要会产生4个问题:
* 缓存和数据库双写一致性问题
* 缓存雪崩问题
* 缓存的并发竞争问题
* 缓存的击穿问题

4.redis快原理:
* 采用了单线程操作，只有在本地化数据时才一步。避免了线程间的频繁切换。
* 采用了非阻塞I/O多路复用机制。
* 纯内存数据库。

5.5种数据类型：
  * String 类型：常规类型，包括数字，字符串。
  * Hash类型：这里value存放结构化的对象，能操作其中的某个字段，类似于map
  * list类型：使用list数据结构，可以保存重复数据，可以使用range命令做分页，也可以用于实现消息队列。
  * set类型：存放不重复值的集合。
  * sorted set类型：多了一个权重参数进行排列的集合类型。

6.键过期策略和内存淘汰机制

    6.1 过期策略

        * 定时删除策略:创建定时器，在时间到了后立刻对其进行删除。过期键比较多时，删除操作会占用一部分cpu时间，当内存不紧张而cpu非常紧张时，会对服务器响应时间和吞吐量有影响。
        * 惰性删除策略:每次从键空间获取键时，都检查是否过期，过期则先执行删除程序，再返回该键。
        * 定期删除:每隔一段时间删除里面的过期键：减少了对cpu的占用，删除操作执行的时长和频率要合理设置。每次执行时，随机取出一定量的键检查，过期则删除，会有局部变量记录检查进度，下一轮调用接着上次处理，一轮完成后，重新开始。
    主从模式下，过期键的删除由主服务器控制，主服务器删除时会向从服务器发送DEL命令，从服务器只在接收到主服务器的命令后再删除，否则不会删除。

7.持久化机制

  数据库写操作流程：

    * 客户端向服务端发送写操作（数据在客户端内存）
    * 数据库服务端接收到请求的数据（数据在服务端内存）
    * 服务端调用系统调用，往磁盘写数据（数据在系统缓存中）
    * 系统将缓冲区中的数据转移到磁盘控制器（数据在磁盘缓存中）
    * 磁盘控制器将数据写到磁盘介质。

  数据库故障，系统内核完整，只要执行到第3步，数据也可以保存
  系统故障，必须要执行到第5步才完整。

    * 通常数据库层面控制多长时间调用一次系统write,写到系统缓存
    * 操作系统默认控制将缓存写到磁盘控制器，可以通过posix api 提供的命令fsync强制刷缓存。
    * 磁盘缓存大多数情况下只开启读缓存，关闭写缓存，这样数据立即写入磁盘。

  数据损坏处理：

  * 通过数据备份来进行恢复。
  * 在备份基础上添加操作日志，记录每次操作行为。可以通过操作日志来恢复数据
  * 不对旧数据进行更改，只是追加方式完成写操作。

  RDB保存

  * RDB机制持久化：在指定的时间间隔内，将内存中的数据集写入磁盘。默认的持久化方式。将内存中的数据以快照的方式写入到二进制文件中，默认为dump.rdb
  可以配置在n秒内如果有M个key被修改就自动保存。

  * 保存时redis调用fork，创建子进程，其负责将数据写入临时文件，由于os的copy on write写时复制机制，当父进程修改时，os会为其创建副本，子进程的地址空间内是fork时整个空间的快照。
  * 子进程将快照写入临时文件后，用临时文件替换原来的快照文件。
  * 持久化时全量的，数据量大会产生频繁的IO操作。
  * 提供命令save和bgsave命令手动调用持久化。

  好处：

    * 备份文件单一，便于归档
    * 方便转移
    * 恢复大数据集时比AOF快。
    * 最大化redis性能，采用子进程异步保存，不影响客户端请求。

  坏处

    * 容易丢失在保存时间间隔内的数据
    * 当子进程工作量比较大时，占用父进程的资源。

  AOF保存机制

    * 将每个收到的写命令，通过write函数追加到文件中，appendonly.aof 当重启时，会重新执行文件中的命令，重建数据库，当然由于系统内核缓存的存在，可能会丢失部分命令，不过可以通过redis配置来强制刷盘。
    3种配置方式：每次立即强刷，每秒钟刷一次，完全依赖os.
    * 当数据文件过大时，提供bgrewriteaof命令，异步将内存快照已命令方式写入临时文件，同时父进程缓存写命令，等待子进程保存完成，更换旧文件后，父进程重新写入命令。
